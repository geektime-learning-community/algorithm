# 05-数组：为什么很多编程语言中数组都从0开始编号？-学习总结

## 如何实现随机访问？

**数组**（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。

**线性表**就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。所以数组元素是**有序**的。其实除了数组，链表、队列、栈等也是线性表结构。

![b6b71ec46935130dff5c4b62cf273477](05-数组：为什么很多编程语言中数组都从0开始编号？-学习总结_files/b6b71ec46935130dff5c4b62cf273477.jpg)

而与线性表相对立的概念是**非线性表**，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

![6ebf42641b5f98f912d36f6bf86f6569](05-数组：为什么很多编程语言中数组都从0开始编号？-学习总结_files/6ebf42641b5f98f912d36f6bf86f6569.jpg)

数组用一组连续的内存空间，来存储一组具有相同类型的数据，这样做的好处是：可以**随机访问**数据，坏处是：要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

**数组是如何实现根据下标随机访问数组元素的？**

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

`a[i]_address = base_address \+ i * data_type_size`

「链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)」这种表述不准确。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，**数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**。

## 低效的“插入”和“删除”

### 插入操作

插入操作低效的原因：如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。所以插入操作的平均情况时间复杂度是 O(n)。

插入操作的改进思路：如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。

### 删除操作

删除操作低效的原因：如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。删除操作的平均情况时间复杂度也为 O(n)。

删除操作的改进思路：在某些特殊场景下，我们并不一定非得追求数组中数据的连续性，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

>如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。

## 警惕数组的访问越界问题

C 语言编译器没有做数组越界的检查，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误，这时就会通过数组访问到其他变量了。

## 容器能否完全替代数组？

针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。

ArrayList 最大的优势就是**可以将很多数组操作的细节封装起来**。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是**支持动态扩容**。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。

以下情况更适合使用数组：

1. 性能问题。Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3. 当要表示多维数组时，用数组往往会更加直观。比如 Object\[][] array；而用容器的话则需要这样定义：ArrayList\<ArrayList> array。

对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

## 为什么数组要从 0 开始编号，而不是从 1 开始呢？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。

计算 a[k] 的内存地址只需要用这个公式：

`a[k]_address = base_address + k * type_size`

如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：

`a[k]_address = base_address + (k-1)*type_size`

从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令，通过下标随机访问数组元素是非常基础的编程操作，效率的优化就要尽可能做到极致。

## 课后思考

### JVM 标记清除算法

大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。

不足：

1. 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。
2. 空间问题。会产生不连续的内存空间碎片。

### 二维数组内存寻址

对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：

address = base_address + ( i * n + j) * type_size

另外，对于数组访问越界造成无限循环，是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。老师的程序，如果是内存地址递减的方式，就会造成无限循环。  