# 07-链表（下）：如何轻松写出正确的链表代码？-学习总结

## 技巧一：理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。代码举例：

- `p->next=q`表示 p 结点中的 next 指针存储了 q 结点的内存地址。

- `p->next=p->next->next`表示p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。

## 技巧二：警惕指针丢失和内存泄漏

插入结点时，一定要注意操作的顺序，比如在 2 个相邻结点间插入结点 x 时，要先把后面的结点的 next 指针指向结点 x，再把结点 x 的 next 指针指向前面的结点。

删除链表结点时，也一定要记得手动释放内存空间，当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。

## 技巧三：利用哨兵简化实现难度

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理，这样代码实现起来较为繁琐，利用「哨兵」可以在不参与业务逻辑的情况下解决这种「边界问题」。

如果引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点，这样插入或删除任何结点都可以统一为相同的代码实现逻辑。这种有哨兵结点的链表叫**带头链表**，没有哨兵结点的叫**不带头链表**。

## 技巧四：重点留意边界条件处理

软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。所以写代码时和写完代码后要检查边界条件是否考虑全面，以及代码在边界条件下是否能正常运行，以提高代码的健壮性。

用来检查链表代码是否正确的边界条件有：

- 如果链表为空时，代码是否能正常工作？ 

- 如果链表只包含一个结点时，代码是否能正常工作？ 

- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

## 技巧五：举例画图，辅助思考

写代码时，可以把代码中的各种情况都举个例子画在纸上，辅助思考，看图写代码思路更清晰。写完代码后也可以举例画图来检查代码是否能走通。

## 技巧六：多写多练，没有捷径

把常见的链表操作用代码多写几遍，熟能生巧，5 个常见的链表操作总结：

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第 n 个结点
- 求链表的中间结点

## 关于「哨兵」

哨兵可以理解为它可以减少特殊情况的判断，比如判空，比如判越界，比如减少链表插入删除中对空链表的判断，比如例子中对i越界的判断。

空与越界可以认为是小概率情况，所以代码每一次操作都走一遍判断，在大部分情况下都会是多余的。

哨兵的巧妙就是提前将这种情况去除，比如给一个哨兵结点，以及将key赋值给数组末元素，让数组遍历不用判断越界也可以因为相等停下来。

使用哨兵的指导思想应该是**将小概率需要的判断先提前扼杀**，比如提前给他一个值让他不为null，或者提前预设值，或者多态的时候提前给个空实现，然后**在每一次操作中不必再判断以增加效率**。  

