# 07 | 链表(下) : 如何轻松的写出正确的链表代码？



 ## 技巧一：理解指针或引用的含义
1.含义：将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。
2.示例：

+ p—>next = q; 表示p节点的后继指针存储了q节点的内存地址。
+ p—>next = p—>next—>next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。

## 技巧二：警惕指针丢失和内存泄漏

### 插入节点
在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏的代码：

```c
p—>next = x;
x—>next = p—>next;
```

 显然这会导致x节点的后继指针指向自身。正确的写法是2句代码交换顺序，即：

```c
x—>next = p—>next;
p—>next = x;
```

### 删除节点
在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a：

```c
p—>next = p—>next—>next;
```

删除链表结点时，也一定要记得手动释放内存空间
 

## 技巧三：利用“哨兵”简化实现难度
###  什么是“哨兵”？

链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。

### 未引入“哨兵”的情况

如果在p节点后插入一个节点，只需2行代码即可搞定：

```c++
new_node—>next = p—>next;
p—>next = new_node;
```

但，若向空链表中插入一个节点，则代码如下：

```c
if(head == null){
	head = new_node;
}
```

如果要删除节点p的后继节点，只需1行代码即可搞定：

```c
p—>next = p—>next—>next;
```

但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：

```c
if(head—>next == null){
	head = null;
}
```

从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。

### 引入“哨兵”的情况

“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。
## 技巧四：重点留意边界条件处理

经常用来检查链表是否正确的边界4个边界条件：

+ 如果链表为空时，代码是否能正常工作？
+ 如果链表只包含一个节点时，代码是否能正常工作？
+ 如果链表只包含两个节点时，代码是否能正常工作？
+ 代码逻辑在处理头尾节点时是否能正常工作？

## 技巧五：举例画图，辅助思考
核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。

## 技巧六：多写多练，没有捷径
5个常见的链表操作：

+ 单链表反转
+ 链表中环的检测
+ 两个有序链表合并
+ 删除链表倒数第n个节点
+ 求链表的中间节点

