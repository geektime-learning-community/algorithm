经典的链表应用场景： LRU缓存淘汰算法
//理解和应用
//空间换时间

//time complexion
单向链表 
        插入
        删除
        =O(1)
        遍历查找/访问
        =O（n）
双向链表
       因为双向链表中的结点已经保存了前驱结点的指针
       所以删除、插入给定指针指向的结点O（1）
       其他优势：对有效链表，按值查询->平均只需查找一半的数据
   应用：Linked Hash Map
 //研究实现原理
 
 //实际软件开发中，不能仅仅用复杂度分析决定使用哪个数据结构来存储数据

//应用例子：
//Java ArrayList，支持动态扩容，优缺点分析。

//Array和LinkedList对比
代码对内存的使用非常苛刻，则使用Array；
但数组的大小限制，可能造成“内存不足”；

//Linkedlist 特点
内存消耗翻倍；
频繁插入、删除，容易造成内存碎片。for example， Java语言，容易造成GC（Garbage Collection）   
       链表
       
// how to write correct Linked List code
//尝试复杂的链表操作:链表反转，有序链表合并；
指针或引用的含义：存储所指对象的内存地址
    p-> next = q;
    p-> next = p->next -> next;
写代码需要注意：如果没先手动释放结点对应的内存空间，就会产生内存泄漏。
               所以要先手动释放空间（注意操作顺序）

//针对链表头结点和尾结点，进行插入和删除操作，需要进行特殊处理。繁琐容易出错。
 为什么删除尾结点代码也用head表示？
     if (head->next == null) ｛ 
        head = null 
     ｝
     
//带头链表的应用包括插入排序、归并排序、动态规划。

//重点留意边界条件处理:常见情形有
    链表为空时；
    链表只包含一个节点时；
    链表只包含两个结点时；
    处理头结点和尾结点时；
    
//举例画图，辅助思考
   练习：
   链空insert
   链头insert
   2个结点间insert

//多练
   5个常见链表操作练习：
    单链反转；
    链表中环检测；
    两个有序的链表合并；
    删除链表倒数的第N个结点；
    求链表中的中间结点；


   
