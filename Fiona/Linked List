经典的链表应用场景： LRU缓存淘汰算法
//理解和应用
//空间换时间

//time complexion
单向链表 
        插入
        删除
        =O(1)
        遍历查找/访问
        =O（n）
双向链表
       因为双向链表中的结点已经保存了前驱结点的指针
       所以删除、插入给定指针指向的结点O（1）
       其他优势：对有效链表，按值查询->平均只需查找一半的数据
   应用：Linked Hash Map
 //研究实现原理
 
 //实际软件开发中，不能仅仅用复杂度分析决定使用哪个数据结构来存储数据

//应用例子：
//Java ArrayList，支持动态扩容，优缺点分析。

//Array和LinkedList对比
代码对内存的使用非常苛刻，则使用Array；
但数组的大小限制，可能造成“内存不足”；

//Linkedlist 特点
内存消耗翻倍；
频繁插入、删除，容易造成内存碎片。for example， Java语言，容易造成GC（Garbage Collection）   
       
       
   
   
