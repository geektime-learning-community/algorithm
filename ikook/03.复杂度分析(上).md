复杂度分析：即时间、空间复杂度分析

复杂度分析是整个算法的精髓，只要掌握了它，数据结构和算法的内容基本就掌握了一半。

### 为什么需要复杂度分析？

通常把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小（事后统计法）。

这种统计方法有非常大的局限性：

#### 1. 测试结果非常依赖测试环境
如硬件环境，Intel Core i9、Intel Core i3 处理器运行速度不可比。

#### 2. 测试结果过受数据规模的影响很大
数据量的差别直接导致算法执行时间的差别。

所以需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

### 大 O 复杂度表示法

![大 O 表示法](https://meto.chinakook.com/%E5%A4%A7%20O%20%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

`T(n)` 表示代码执行的时间；`n` 表示数据规模的大小；`f(n)` 表示每行代码执行的次数总和。因为这是一个公式，所以用 `f(n)` 来表示。公式中
的 `O`，表示代码的执行时间 `T(n)` 与 `f(n)` 表达式成正比。

它表示代码执行时间随数据规模增长的变化趋势，所以时间复杂度叫作渐进时间复杂度。

当 `n` 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录
一个最大量级就可以了，例如：`T(n) = O(2n+2)、T(n)=O(2n^2+2n+3)` 就可以记为 `T(n) = O(n)； T(n) = O(n^2)`。

### 时间复杂度分析

#### 1. 只关注循环执行次数最多的一段代码

在分析一个算法、一段代码的时间复杂度的时候，就只关注循环执行次数最多的那一段代码就可以了。

#### 2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

总的时间复杂度就等于量级最大的那段代码的时间复杂度。公式就是：如果 `T1(n)=O(f(n))，T2(n)=O(g(n))`;
那么 `T(n)=T1(n)+T2(n)=max(O(f(n), O(g(n))) =O(max(f(n), g(n)))`。

#### 3. 乘法法则：嵌套代码的复杂度就等于嵌套内外代码复杂度的乘积。

乘法法则适用于嵌套循环的代码。
公式为：如果 `T1(n)=O(f(n))，T2(n)=O(g(n))`, 那么 `T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))`.

例子：时间复杂度为 O(n^2)
```
 int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }
```

### 几种常见时间复杂度实例分析

#### 常见的复杂度量级：

![复杂度量级](https://meto.chinakook.com/%E5%B8%B8%E8%A7%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg)

这些复杂度量级可以粗略的分为两类：**多项式量级和非多项式量级**。其中，非多项式量级只有两个：`O(2^n)`、`O(n!)`

时间复杂度为**非多项式量级**的算法问题叫作 **NP 问题**：

**当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以非多项式
时间复杂度的算法是非常低效的算法。**

#### 多项式时间复杂度：

##### 1. O(1)

`O(1)` 只是常量级时间复杂度的一种表示方法。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码
其时间复杂度也是 `O(1)`。

##### 2. O(logn)、O(nlogn)

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。

例子：
```
 i=1;
 while (i <= n)  {
   i = i * 2;
 }
```
说明：变量 i 的值从 1 开始取，每循环一次就乘以 2，当大于 n 时，循环结束。变量 i 的取值可以转换为「等比数列」：

![等比数列](https://meto.chinakook.com/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97.jpg)

所以，只需要知道 x 的取值，就知道了这行代码执行的次数，`2^x = n --> x = log2 n（以 2 为底 n 的对数）`

采用大 `O` 标记复杂度，可以忽略系数，则可以忽略对数的“底”，即该例子的时间复杂度为 `O(log n)`。

同样的，`O(nlog n)` 就是一段时间复杂度为 `O(log n)` 的代码，循环执行了 n 遍，则这段代码的时间复杂度就是 `O(nlog n)`。

##### 3. O(m+n)、O(m*n)

如果一段代码的复杂度由两个数据的规模来决定（如 m 和 n），则无法评估 m 和 n 到底是谁的量级大，所以在表示复杂度的时候，
不能直接简单的利用「加法法则」或者是「乘法法则」，那时间复杂度则为 `O(m+n)、O(m*n)`

### 空间复杂度分析

前面提到，**时间复杂度全称为渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比，则空间复杂度的全称为渐进
空间复杂度，表示算法的存储空间与数据规模之间的增长关系。**

例如有一段代码：
```
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

和时间复杂度分析一样，第 2 行代码，申请了一个空间存储变量 i，但是它是常量阶，与数据规模 n 没有关系，直接忽略。第 3 行代码申请了
一个大小为 n 的 int 数组，除此之外，剩下的代码都没有占用更多的空间，则这段代码的空间复杂度就是 O(n)

**常见的空间复杂度就是 O(1)、O(n)、O(n^2)**，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。

### 小结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的
算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：**O(1), O(log n)、O(n)、O(nlog n)、O(n^2).**

复杂度分析并不难，关键在于多练。