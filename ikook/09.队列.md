### 开篇：

CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理
性能下降。所以线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。

**当向固定大小的线程池中请求一个线程时，如果线程池中没空闲资源了，这个时候线程池如何处理这个请求? 是拒绝请求
还是排队请求？各种处理策略又是怎么实现的呢？**

实际上，这些问题并不复杂，其底层的数据结构就是「**队列（queue）**」

### 如何理解队列？

可以把队列想象成排队买票，先来的先买，后来的只能站在末尾等待，不允许插队。先进者先出，这就是“**队列**”。

队列和栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，
从队列头部取一个元素。所以，队列跟栈一样，是一种操作受限的线性表数据结构。

![](https://meto.chinakook.com/9-1.jpg)

### 顺序队列和链式队列

跟栈一样，队列可以用数据来实现，叫作顺序队列；也可以用链表来实现，叫作链式队列。

对于栈来说，只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向
队尾。

![](https://meto.chinakook.com/9-2.jpg)

![](https://meto.chinakook.com/9-3.jpg)


随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组还有空闲空间，也无法继续往队列
中添加数据了。这时候就需要用「**数据搬移**」。但是如果每次出队操作都搬移数据，出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)
要解决这个问题，只需要在入队操作时，判断是否有空闲空间，如果没有空闲空间，再集中触发一次数据的搬移操作。

那入队函数 enqueeu() 的实现为：
```
  // 入队操作，将 item 放入队尾
  public boolean enqueue(String item) {
    // tail == n 表示队列末尾没有空间了
    if (tail == n) {
      // tail ==n && head==0，表示整个队列都占满了
      if (head == 0) return false;
      // 数据搬移
      for (int i = head; i < tail; ++i) {
        items[i-head] = items[i];
      }
      // 搬移完之后重新更新 head 和 tail
      tail -= head;
      head = 0;
    }
    
    items[tail] = item;
    ++tail;
    return true;
  }
```
基于这种实现思路，出队操作的时间复杂度不变，仍然是 O(1)，但入队操作的时间复杂度变为了：最好 O(1), 最坏 O(n)
平均 O(1)。

#### 基于链表的队列实现方法：

和数据一样，同样需要 head 指针和 tail 指针。分别指向链表的第一个节点和最后一个节点。入队时：tail->next = new_node.
出队时：head = head->next。

![](https://meto.chinakook.com/9-4.jpg)

### 循环队列

循环队列，顾名思义，就像一个环。如下图：

![](https://meto.chinakook.com/9-5jpg)

图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时
候，并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，将 b 放入下标
为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：

![](https://meto.chinakook.com/9-6.jpg)

通过这样的方法，可以避免数据的搬移操作。实现循环队列最关键的是：确定好队列空和队列满的判定条件。

![](https://meto.chinakook.com/9-7.jpg)

如图中队列满的情况，tail = 3，head = 4，n = 8，总结一个规律就是：（3+1）% 8 = 4。所以队满时：（tail+1）% n = head

当队列满时，tail 指向的位置实际上是没有存储数据的，所以，循环队列会浪费一个数据的存储空间。（能不能改进呢？）
```
public class CircularQueue {
  // 数组：items，数组大小：n
  private String[] items;
  private int n = 0;
  // head 表示队头下标，tail 表示队尾下标
  private int head = 0;
  private int tail = 0;

  // 申请一个大小为 capacity 的数组
  public CircularQueue(int capacity) {
    items = new String[capacity];
    n = capacity;
  }

  // 入队
  public boolean enqueue(String item) {
    // 队列满了
    if ((tail + 1) % n == head) return false;
    items[tail] = item;
    tail = (tail + 1) % n;
    return true;
  }

  // 出队
  public String dequeue() {
    // 如果 head == tail 表示队列为空
    if (head == tail) return null;
    String ret = items[head];
    head = (head + 1) % n;
    return ret;
  }
}
```

#### 阻塞队列和并发队列

在实际开发中，一些具有特殊特性的队列应用会比较广泛，比如阻塞队列和并发队列。

阻塞队列其实就是队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从对头取数据会被阻塞。因为此时
还没有数据可取，直到队列中有数据才返回；如果队列已经满了，插入数据的操作就会被阻塞，直到队列中有空闲位置
后再插入数据，然后再返回。

![](https://meto.chinakook.com/9-8.jpg)

上述定义其实就是一个“生产者-消费者模型”。可以实现阻塞队列轻松实现一个“生产者-消费者模型”

基于阻塞队列，还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率：

![](https://meto.chinakook.com/9-9.jpg)

在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全的问题，那如何实现一个线程安全的队列呢？

线程安全队列叫作并发队列。最简单直接的实现方式就是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度
会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的
并发队列。


### 开篇解答

线程池中没空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是怎么实现的呢？

一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲
线程时，取出排队的请求继续处理。那如何存储排队的请求？

为了公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。前面说过，队列有基于链表
和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？

基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请
求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。

而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会
被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大
导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。

除了队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，
**对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。**



















