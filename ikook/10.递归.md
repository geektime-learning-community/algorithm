### 开篇：

推荐注册功能：用户 A 推荐用户 B  注册，用户 B 又推荐了用户 C 来注册。这时，用户 C 的“最终推荐人”为
用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。

一般来说，会通过数据库来记录这种推荐关系。在数据库表中，可以记录两行数据，其中 actor_id 表示用户
id，referrer_id 表示推荐人 id。

![](https://meto.chinakook.com/10-1.jpg)

那么，给定一个用户 ID，如何查找这个用户的“最终推荐人”？这个问题可以用递归来实现。

### 如何理解“递归”？

递归是一种应用非常广泛的算法（或者编程技巧）。很多数据结构与算法的编码实现都要用到递归。比如
DFS 深度优先搜索、前中后序二叉树遍历等。

举个例子：

带女友去电影院看电影，女友问，咱们现在坐在第几排？电影院太黑，没法数。于是就问前面一排的人他
在第几排，只要在他的数字上加一，就知道自己在第几排了，但是前面的人也看不清，所以他也问他前面
的人。于是一排一排往前问，直到第一排的人。然后再一排一排的把数字传回来，就知道自己在第几排。

这是一个典型的递归求解问题的分解过程。去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问
题都可以用递推公式来表示。如上面的例子，用递推公式来表示就是：
```
f(n) = f(n-1)+1
```
f(n) 表示想要知道自己在第几排，f(n-1) 表示前面一排所在的排，f(1) = 1 表示第一排的人知道自己在第一
排。改写递推公式为递归代码：
```
int f(int n) {
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```

### 递归需要满足三个条件

什么样的问题可以用递归来解决呢？只要同时满足以下三个条件，就可以用递归来解决。

1.一个问题的解可以分解为几个子问题的解

    子问题就是数据规模更小的问题。

2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。

3.存在终止条件。

    把问题分解为子问题，把子问题分解为子子问题，一层层分解下去，不能存在无限循环，这就需要终止条件。

### 如何编写递归代码

写递归代码最关键的是写出**递推公式，找到终止条件**，剩下将递推公式改写为代码就很简单了。也就是说写
递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲出终止
条件，最后将递推公式和终止条件翻译成代码。

对于递归代码，不要试图想清楚整个递归过程的做法，如果这样想，实际上是进入了一个思维误区。如果一个
问题 A 可以分解为若干子问题 B、C、D，假设子问题 B、C、D 已经解决，在此基础上考虑如何解决 A  问题。
而且，只需要考虑 A 问题与子问题 B、C、D 两层之间的关系即可，不需要一层层往下思考子问题与子子问题之
间的关系，要屏蔽掉递归细节。

因此，编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不要想一层层的调用关系，不要试
图用人脑去分解递归的每个步骤。


### 解答开篇

如何找到“最终推荐人”？以下是解决方案
```
long findRootReferrerId(long actorId) {
  Long referrerId = select referrer_id from [table] where actor_id = actorId;
  if (referrerId == null) return actorId;
  return findRootReferrerId(referrerId);
}
```

用三行代码就能搞定。不过在实际的项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。

第一，如果递归很深，可能会出现堆栈溢出的问题。

第二，如果数据库里存在脏数据，还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，
测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐
人是 C，C 的推荐人是 A，这样就会发生死循环。

第一个问题可以用限制递归深度来解决，第二个问题，也可以用限制递归来解决，不过，还有一个更高
级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。


### 小结

递归是一种非常高效、简洁的编码技巧。只要满足“三个条件”的问题就可以通过递归代码来解决。递归
代码虽然简洁高效，但是，递归代码也有很多弊端。比如：堆栈溢出、重复计算、函数调用耗时多、空
间复杂度高等。所以，在编写递归代码时，一定要控制好这些副作用。