首先，在大部分编程语言中，数组都是从 0 开始编号的，但是为什么数组要从 0 开始编号呢？从 1 开始不是更加符合人类的思维习惯吗？


### 如何实现随机访问？

什么是数组？

**数组（Array）是一种线性表数据结构，它是一组连续的内存空间，来存储一组具有相同类型的数据。**

这个定义里面存在几个关键词。

第一是**线性表（Linear List）**。线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。

![](https://meto.chinakook.com/%C2%B71.jpg)

与之相对应的是**非线性表**，比如二叉树、堆、图等。之所以叫做非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

![](https://meto.chinakook.com/2.jpg)

第二个是**连续的内存空间和相同类型的数据。**

数组是如何实现根据下标随机访问数据元素的呢？

如有一个长度为 10 的 int 类型的数组 `int[] a = new int[10]`，如图，计算机会给数组 `int[10]`，分配一块连续的内存空间 `1000~1039`，其中，
内存块的首地址是 `base_address = 1000`。

![](https://meto.chinakook.com/3.jpg)

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要访问数组中的某个元素时，它会首先通过下面
的寻址公式，计算出该元素存储的内存地址：

```
a[i]_address = base_address + i * data_type_size
```

其中， `data_type_size` 表示数组中每个元素的大小。在这个例子中，数组中存储的是 `int` 类型的数据，所有 `data_type_size` 则为 4 个字节。

这里有一个**错误**面试答案：

问，数组和链表的区别

很多人都回答：链表适合插入、删除，时间复杂度为 `O(1)`；数组适合查找，查找时间复杂度为 `O(1)`。

实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 `O(1)`。即便是排好序的数组，用二分查找，时间复杂度
也是 `O(log n)`，所以，正确的表述应该是：**数组支持随机访问，根据下标随机访问的时间复杂度为 `O(1)`。**


### 低效的“插入”和“删除”

数组为了保持内存数据的连续性，会导致插入、删除这两个方法操作比较低效。究竟为什么会导致低效，有哪些改进的方法？

#### 插入操作

假设数据的长度为 n ，将一个数据插入到数据中的第 k 个位置，为了把第 k 个位置腾出来，给新来的数据，需要将第 `k~n` 个位置上的元素都顺序向后
挪一位。那插入操作的时间复杂度：最好 `O(1)`，最坏 `O(n)`，平均 `O(n)`。

如果数组中数据是有序的，在插入一个新的元素时，就必须按照上面的方式搬移 `k` 位置之后的数据。但是，如果数组中的数据并没有任何规律，数组
只是被当作一个存储数据的集合，在这种情况下，为了避免大规模的数据搬移，只需要将第 `k` 位的数据搬移到数据元素的最后，把新的元素直接放入第 
`k` 个位置就好了。

如：数组 `a[10]` 中存储了 5 个元素：`a, b, c, d, e`。现在需要将元素 `x` 插入到第 3 个位置，只需要将 `c` 放入到 `a[5]`，将 `a[2]` 赋值为 `x` 即可。

![](https://meto.chinakook.com/4.jpg)

利用这种方式，可以将时间复杂度降为 `O(1)`。这个处理思想在快排中也会用到。

#### 删除操作

跟插入操作类似，如果要删除第 `k` 个位置的数据，为了保持内存的连续性，也需要搬移数据。删除操作的时间复杂度：最好 `O(1)`，
最坏 `O(n)`, 平均 `O(n)`。

如果在某些特殊场景下，不一定非要追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率就会提高很多。

如：数组 `a[10]` 中存储了 8 个元素：`a，b，c，d，e，f，g`，h。现在，要依次删除 `a，b，c` 三个元素。

![](https://meto.chinakook.com/5.jpg)

为了避免 `d，e，f，g，h` 被搬移三次，可以先记录下已经删除的数据。每次删除操作并不是真正地搬移数据，只是记录数据已经被
删除。当数组中没有更多空间存储数据时，再触发执行一次真正的删除操作。

这个操作就是 JVM 标记清除垃圾回收算法的核心思想。

### 解答开篇疑问

为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始？

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移”。如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也
就是首地址，a[k] 就表示偏移为 k 个 type_size 的位置，所以计算 a[k] 的内存地址公式为：

```
a[k]_address = base_address + k * data_type_size
```

但是如果数组从 `1` 开始计数，计算数组元素 `a[k]` 的内存地址就变为：

```
a[k]_address = base_address +（ k-1）* data_type_size
```

这样每次随机访问数组元素都多了一次减法运算，对 CPU 来说，就多了一次减法指令。

### 习题

问：类比一维数组的内存寻址公式，二维数组的内存寻址公式是？

答：对于 `m*n` 的二维数组 `a[m][n]，a[i][j]` 的寻址公式是：

```
a[i][j]_address = base_address + ( i * n + j ) * data_type_size
```