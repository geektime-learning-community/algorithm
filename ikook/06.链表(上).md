链表的一个经典应用场景就是 LRU 缓存淘汰算法。

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据路缓存、浏览器缓存等。

缓存的大小有限，所以需要缓存淘汰策略，来决定缓存被用满时，哪些数据应该被清理出去。常见的缓存淘汰策略有三种：`先进先出策略 FIFO
（First In，First OUT）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）`

### 常见链表结构

从底层的存储结构上来看，链表不需要数组那样一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。

![](https://meto.chinakook.com/1905061.jpg)

最常见的链表结构有三种：`单链表、双向链表、循环链表`

#### 单链表

上面说到，链表通过“指针”将一组零散的内存块串联起来。其中，将内存块称为链表的“`节点`”。为了将所有的节点
串起来，每个链表的节点除了存储数据之外，还有记录链上的下一个节点的地址。将记录下个节点地址的指针叫做`后继指针 next`。

![](https://meto.chinakook.com/1905066.jpg)

在链表中插入或者删除一个数据时，不需要为了保持内存空间的连续性而搬移节点，所以在链表中插入和删除一个数据
非常快速，对应的时间复杂度为 O(1)。

但由于链表的内存空间不是连续的，所以不能通过首地址和下标计算内存地址，所以只能根据指针依次遍历。所以查找
的时间复杂度为 O(n)。

#### 循环链表

循环链表是一种特殊的单链表，它跟单链表唯一的区别就是在尾节点，循环链表的尾节点指针指向链表的头结点，从而形
一个首尾相连的链，所以叫做循环链表。

![](https://meto.chinakook.com/1905062.jpg)

循环链表的优点是从链尾到链头比较方便，当处理的数据具有环形结构特点时，特别适合采用循环链表。

#### 双向链表

顾名思义，双向链表支持两个方向，每个节点不止有一个后继指针 next 指向后面的节点，还有一个前驱指针 prev 指向前
面的节点。

![](https://meto.chinakook.com/1905063.jpg)

双向链表需要额外的两个空间来存储后继节点和前驱节点的地址。所以，如果存储同样的数据，双向链表要比单链表占用
更多的空间。但双向链表在某些情况下的插入、删除、查找等操作都要比单链表简单、高效。

使用双向链表来代替单链表有一个设计思想：用空间换时间

当内存空间充足的时候，如果更加追求代码的执行速度，就可以选择空间复杂度较高，但时间复杂度较低的算法或者数据
结构。

`缓存`正是利用空间换时间的设计思想。

总结一下，对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通
消耗更多的时间（时间换空间）来降低内存的消耗。

### 双向循环链表

![](https://meto.chinakook.com/1905064.jpg)

### 链表、数据性能比拼

![](https://meto.chinakook.com/1905065.jpg)

### 使用链表实现 LRU 缓存淘汰算法

思路：维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的，当有一个新的数据被访问时，从链表的
头部开始顺序遍历链表。

1.如果此数据之前已经被缓存在链表中，遍历得到这个数据对象的节点，将其从原来的位置删除，然后再插入
到链表的头部。

2.如果此数据没有缓存链表中，又可以分为两种情况：

- 如果此时缓存未满，则将此节点直接插入到链表的头部。
- 如果此时缓存已满，则链表尾节点删除，将新的数据节点插入到链表的头部。

这样就实现了一个 LRU 缓存了。。

基于这种链表的实现思路，缓存的访问时间复杂度为 O(n)。可以继续优化这个算法，通过 `散列表（Hash Table）`来
记录每个数据的位置，可以将缓存访问的时间复杂度降为 O(1)。