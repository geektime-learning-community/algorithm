# 数据节后和算法--复杂度分析（上）

## 1、数据结构和算法
    解决‘快’和‘省’的问题

## 2、复杂度分析
 * 时间复杂度
 * 空间复杂度

    分析算法执行效率与数据鬼面膜之间的增长关系。越高阶复杂度的算法，执行效率越低。

    > 低阶到高阶</br>
    > O(1)＜O(logn)＜O(n)＜O(nlogn)＜O(n^2)


## 大O复杂度表示法

![img](https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png)

> T(n)表示代码执行的时间</br>
> n表示数据规模的大小</br>
> f(n)表示每行代码执行次数的总和</br>
> O表示代码的执行时间 T(n) 与 f(n) 表达式成正比。<br>
> 


1. 只关注循环次数最多的一段代码 

```
//T(n)=O(n)  
int cal(int n){
    int sum = 0;
    int i = 1 ;
    for(;i<=n;++i){
        sum = sum + i;
    }
    return sum;
}
```

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
> 如果 T1(n)=O(f(n))，T2(n)=O(g(n))，那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n)))=O(max(f(n), g(n)))

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
> T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)

## 复杂度分析法则
* 单段代码看高频：比如循环。
* 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
* 嵌套代码求乘积：比如递归、多重循环等
* 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相