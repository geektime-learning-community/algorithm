# 复杂度分析（下）

### 最好时间复杂度
这段代码返回的是目标值x在数组中的下标，最好情况就是下标为0也就是第1个就找到了，时间复杂度为O(1)
```
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}

```

### 最坏时间复杂度
还是上面这段代码，它也有可能在数组最后一个才匹配到那么时间复杂度是O(n)

### 平均时间复杂度
其实大多数时候我们分析的都是平均复杂度，上面两种都太极端了。
```
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}

```
在这个例子中，要找的值有可能在数组中也有可能不再数组中，所以概率是1/2。另外如果在数组中，找到的概率是1/n，根据概率乘法得到，任意位置的概率是1/2 x 1/n = 1/2n。大O表示法中常量和系数是可以忽略的，所以平均复杂度是O(n)

