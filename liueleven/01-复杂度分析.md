# 复杂度分析

> 更新时间：2019-04-17
> 上次时间：2019-03-12

### 为什么需要进行复杂度分析？

现在有一个定时任务，每秒钟会打印出“hello world”保存到文件，问你一天这个文件有多大？

你会觉得很简单，直接让它跑一天最后看下这个文件占多大内存，不就可以了。但如果你算出一个“hello world”占11个字节，然后11 x 3600 x 24这样算是不是快一点呢？

复杂度分析可以不依赖于环境和数据规模就可以预测结果。

复杂度分析又分为时间和空间复杂度分析

### 大O表示法

![image](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)



### 先尝试的分析下：

```
 1 int cal(int n) {
 2  int sum = 0;
 3  int i = 1;
 4  for (; i <= n; ++i) {
 5    sum = sum + i;
 6  }
 7  return sum;
 8 }

```

假设每一行执行时间的单位是t，那么2、3行就是2t了，4、5行是2nt，所以总共时间是`T(n)=(2n+2)t`,你会发现真正影响时间的是变量n，其它常量级别的可以忽略掉，用**大O表示法就是`T(n)=O(n)`**，大O表示的是代码和时间**变化趋势**，而不是说具体的执行时间

### 时间复杂度

**时间复杂度：**
表示代码和时间上的关系

我们知道了上一个例子的时间复杂度是O(n),一般分为以下几个复杂度等级

多项式量级：

- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 次方阶 O(n^k)

非多项式量级：

- **指数阶 O(2^n)**
- **阶乘阶 O(n!)**

尤其要注意2个非多项式量级，随着n的增大，复杂度急剧增加，代码中要减少这种情况的发生

- 最好、最坏、平均时间复杂度

```
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

该代码中，是要找出x的下标，最好的情况是1次，最坏的是n次，平均的是n次

### 空间复杂度

**空间复杂度：**
表示代码和存储空间上的关系,和时间复杂度类似

- O(1)
- O(n)
- O(n^2)