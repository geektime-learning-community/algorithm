# 数组

### 什么是数组
是一种线性表数据结构，用一组连续的内存，存储具有相同类型的数据。数组支持随机访问，根据下标访问时间复杂度是O(1)


### 数组的查找
数组分配法人内存是连续的，计算机可以通过地址来访问内存中的数据，计算机会通过寻址公式来找到地址：
```
// data_type_size: 每个元素的大小
// base_address：首地址
// i：数组的长度
a[i]_address = base_address + i * data_type_size
```

### 数组的插入和删除
如果现在要在一个有序数组中间插入元素，那么要把后面的都往后挪，腾出一个位置，这个时候时间复杂度是O(n)，但如果是非有序的那么只要替换插入的那个位置的元素，并把替换的元素放到数组尾部时间复杂度是O(1)

删除和插入都一样，因为要保证数组连续性还是要挪动元素，所以时间复杂度是O(1)，有序情况下是O(n)

但是我们对时间复杂度O(n)显然有点不满意，希望改进下，可以使用空间换时间的思想，例如删除一个数组中间元素，只是暂时**标记**为已删除，等空间不够用的时候再统一挪动元素，这样就大大减少了数据搬移的时间。**JVM的标记清除垃圾回收算法就是这个思想**

### 警惕数组越界访问
获取数组的内容实际上是对地址的访问，C是可以对地址进行访问的，假设a[3]的地址刚好映射到i中，那么a[3]=0等价与i=0。会导致这段代码无限循环，并且很难找到这个bug
```
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}

```
一般现在的gcc各种标准默认开启栈保护，要想复现循环问题可以手动关闭栈保护功能：
```
// -o编译   -fno-stack-protector关闭栈保护
gcc  -fno-stack-protector -o arr ./arrayoutofboundindex.c
// 执行编译后的文件
./arr
// 控制台结果,无限输出Hello World
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
.
.
.
```

### 一个有趣的问题
为什么数组的下标是从0开始的而不是1，你可能会说计算机就是从0开始的，符合习惯，好像也有点道理，程序员得拿数据说话，借用前面的寻址公式，如果是从1开始访问，那么CPU就会多一次减指令的执行，作为一个最最最基本的数据结构，追求的就是极致！！！
```
// data_type_size: 每个元素的大小
// base_address：首地址
// i：数组的长度
a[i]_address = base_address + (i-1) * data_type_size
```

### 拓展-二维数组的寻址
二维数组是a[m][n],根据一唯数组可以推导出：
```
a[m][n]_address = base_address + (m*i+n) * data_size
```
